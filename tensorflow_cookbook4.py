# -*- coding: utf-8 -*-
"""tensorflow_cookbook4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pLgUzJit4ymwMCxMDzxR86c8VxA7Tvu1
"""

import random; from IPython.display import display,HTML
from IPython.core.magic import register_line_magic
@register_line_magic
def radial_gradient_header(params):
    randi=str(random.randint(1,9999999))
    params=params.split('|'); string=params[0]
    if len(params)==1: 
        font_size=str(30); font_family='Ewert'
    elif len(params)==2: 
        font_size=params[1]; font_family='Ewert'
    else:
        font_size=params[1]; font_family=params[2]
    html_str="""<style>@import 'https://fonts.googleapis.com/css?"""+\
    """family="""+font_family+"""'; #div"""+randi+\
    """ {background:white; padding:2px;}
    .textrg {display:inline-block; font-size:"""+font_size+\
    """px; line-height:1.1; padding:5px; font-family:"""+font_family+\
    """,sans-serif; text-transform:uppercase;
       background:radial-gradient(
           circle farthest-corner at center center,
           orange,magenta,cyan) no-repeat;
       -webkit-background-clip:text;
       -webkit-text-fill-color:transparent;}</style>
    <div id='div"""+randi+"""'><text class='textrg'>"""+string+\
    """</text></div>"""
    display(HTML(html_str))

import warnings; warnings.filterwarnings('ignore')
import pandas as pd,numpy as np
import pylab as pl,tensorflow as tf
from sklearn import datasets
import sklearn.model_selection as sms
from tensorflow.data import Dataset as tds

def pd_style():
    return [dict(selector='th',
                 props=[('font-size','10pt'),('min-width','45px')]),
            dict(selector='td',
                 props=[('padding','0em 0em'),('min-width','45px')]),
            dict(selector='tr:hover th:hover',
                 props=[('font-size','11pt'),('max-width','45px'),
                        ('text-shadow','3px 3px 3px #aaa')]),
            dict(selector='tr:hover td:hover',
                 props=[('font-size','10pt'),('max-width','45px'),
                        ('text-shadow','3px 3px 3px #aaa')])]

# Commented out IPython magic to ensure Python compatibility.
# %radial_gradient_header Data Exploration

boston_data=datasets.load_boston()
columns=boston_data.feature_names
boston_df=pd.DataFrame(boston_data.data,columns=columns)
boston_df['MEDV']=boston_data.target
boston_df[['CHAS','RAD']]=boston_df[['CHAS','RAD']].astype('int64')
numeric_features=\
boston_df.columns[[0,2,4,5,6,7,9,10,11,12,13]]
stats=boston_df.describe().transpose()
dfn=boston_df.copy()
for nc in numeric_features:
    mean=stats.loc[nc,'mean']; std=stats.loc[nc,'std']
    dfn.loc[:,nc]=(dfn.loc[:,nc]-mean)/std
dfn[numeric_features].tail(int(10)).style.bar(
    align='mid',color=['#55eeee','#ee55ee'],
    subset=numeric_features).set_precision(3)\
   .set_table_styles(pd_style())

# Commented out IPython magic to ensure Python compatibility.
# %radial_gradient_header Data Processing

tfnumeric_features=[]
for nc in numeric_features[:-1]:
    tfnumeric_features.append(
        tf.feature_column.numeric_column(key=nc)) 
for nf in tfnumeric_features: 
    print(str(nf)); break
fchas=tf.feature_column\
.categorical_column_with_vocabulary_list(
    key='CHAS',vocabulary_list=[0,1])
frad=tf.feature_column\
.categorical_column_with_vocabulary_list(
    key='RAD',vocabulary_list=[1,2,3,4,5,6,7,8,24])
tfcategorical_features=[]
fchas_emb=tf.feature_column.embedding_column(fchas,dimension=2)
tfcategorical_features.append(fchas_emb)
frad_emb=tf.feature_column.embedding_column(frad,dimension=9)
tfcategorical_features.append(frad_emb)
print(str(tfcategorical_features[0]))
fzn=tf.feature_column.numeric_column(key='ZN')
tfbucketized_features=[tf.feature_column.bucketized_column(
    source_column=fzn,boundaries=[30,70,100])]
print(str(tfbucketized_features[0]))

features=(tfnumeric_features+tfbucketized_features+tfcategorical_features)
dfn_train,dfn_test=sms.train_test_split(dfn,train_size=.8,shuffle=True)
print(str([len(dfn_train),len(dfn_test)]))

batch_size=8
def train_input_fn(dfn_train,batch_size):
    dft=dfn_train.copy()
    x_train,y_train=dft,dft.pop('MEDV')
    ds_train=tds.from_tensor_slices((dict(x_train),y_train))
    return ds_train.shuffle(len(x_train)).repeat().batch(batch_size)
ds_train=train_input_fn(dfn_train,batch_size)
batch=next(iter(ds_train))
print('keys: \n%s'%batch[0].keys())
print('batch values of `ZN`: \n %s'%batch[0]['ZN'])

def test_input_fn(dfn_test,batch_size):
    dft2=dfn_test.copy()
    x_test,y_test=dft2,dft2.pop('MEDV')
    ds_test=tds.from_tensor_slices((dict(x_test),y_test))
    return ds_test.batch(batch_size)
ds_test=test_input_fn(dfn_test,batch_size)
batch=next(iter(ds_test))
print('keys: \n%s'%batch[0].keys())
print('batch values of `CHAS`: \n%s'%batch[0]['CHAS'])

# Commented out IPython magic to ensure Python compatibility.
# %radial_gradient_header Model Training

reg=tf.estimator.DNNRegressor(
    feature_columns=features,hidden_units=[104,52],
    model_dir='models/boston-dnnregressor/');

epochs=1000
steps=epochs*int(np.ceil(len(dfn_train)/batch_size))
print('training steps: %d'%steps)
reg.train(input_fn=lambda:train_input_fn(dfn_train,batch_size),steps=steps);

# Commented out IPython magic to ensure Python compatibility.
# %radial_gradient_header Model Evaluation

reloaded_reg=tf.estimator.DNNRegressor(
    feature_columns=features,hidden_units=[104,52],
    warm_start_from='models/boston-dnnregressor/',
    model_dir='models/boston-dnnregressor/');

test_results=reloaded_reg.evaluate(
    input_fn=lambda:test_input_fn(dfn_test,batch_size))
for key in test_results:
    print('{}: {}'.format(key,test_results[key]))
print('test average loss% {:.4f}'\
      .format(test_results['average_loss']))

y_test_pred=reg.predict(
    input_fn=lambda:test_input_fn(dfn_test,batch_size))
py_test=[]
for i in range(len(dfn_test)):
    py_test.append(next(iter(y_test_pred))['predictions'][0])

pl.figure(figsize=(10,4))
pl.plot(range(len(dfn_test)),dfn_test['MEDV'],
        '-o',label='real data',c='#55eeee',ms=7)
pl.plot(range(len(dfn_test)),py_test,
        '-o',label='predictions',c='#ee55ee',ms=5)
pl.tight_layout(); pl.grid(); pl.legend();