# -*- coding: utf-8 -*-
"""codejam_notes1A.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jraa8jrlwJ7sBBYuUBGF2zXGzSbQd_m2

# Task 1. Append Sort (12pts, 14pts)

We have a list of integers X1,X2,…,XN. 

We would like them to be in strictly increasing order, but unfortunately, we cannot reorder them. 

This means that usual sorting algorithms will not work.

Our only option is to change them by appending digits 0 through 9 to their right (in base 10). 

For example, if one of the integers is 10, you can turn it into 100 or 109 with a single append operation, 

or into 1034 with two operations (as seen in the image below).

Given the current list, what is the minimum number of single digit append operations that are necessary 

for the list to be in strictly increasing order?

For example, if the list is 100,7,10, 

we can use 4 total operations to make it into a sorted list, as the following image shows.

### Input
The first line of the input gives the number of test cases, T. T test cases follow. 

Each test case is described in two lines. 

The first line of a test case contains a single integer N, the number of integers in the list. 

The second line contains N integers X1,X2,…,XN, the members of the list.

### Output
For each test case, output one line containing Case #x: y, 

where x is the test case number (starting from 1) and 

y is the minimum number of single digit append operations needed for the list to be in strictly increasing order.

### Limits

Time limit: 10 seconds.

Memory limit: 1 GB.

1≤T≤100.

Test Set 1 (Visible Verdict)

2≤N≤3.

1≤Xi≤100, for all i.

Test Set 2 (Visible Verdict)

2≤N≤100.

1≤Xi≤10^9, for all i.

Sample

Sample Input

4

3

100 7 10

2

10 10

3

4 19 1

3

1 2 3

Sample Output

Case #1: 4

Case #2: 1

Case #3: 2

Case #4: 0

In Sample Case #1, the input is the same as in the example given in the problem statement. 

As the image shows, the list can be turned into a sorted list with 4 operations. 

Notice that the last two integers need to end up with at least 3 digits (requiring at least 3 append operations in total). 

If all of the final numbers had exactly three digits, the second would be larger than the third because it starts with a 7 instead of a 1. 

This means we cannot do it with fewer than 4 operations.

In Sample Case #2, notice that the list needs to be in strictly increasing order, so we have to do at least one operation. 

In this case, any valid append operation to the second integer works.

In Sample Case #3, we can use two append operations to get the list to 4,19,193.

In Sample Case #4, the given list is already in strictly increasing order, so no operations are necessary.
"""

T=int(input())
for t in range(T):
    I=int(input())
    N=input()
    N=[n for n in N.split()]
    S,MIN,i=0,len(N[0]),1
 #   print(t,I,N,S,MIN)
 # too many conditions,it needs to change numbers really
    while i<I:
        LEN=min(len(N[i-1]),len(N[i]))
        cond1=int(N[i-1][:LEN])<int(N[i][:LEN])
        cond2=int(N[i-1][:LEN])==int(N[i][:LEN])
        cond3=int(N[i-1][:LEN])>int(N[i][:LEN])
        if len(N[i-1])<len(N[i]) and MIN<len(N[i]):
            MIN=len(N[i])
        elif len(N[i-1])<len(N[i]) and MIN>len(N[i]):
            if cond3:
                S+=MIN-len(N[i])+1; MIN+=1
            if cond1 or cond2:
                S+=MIN-len(N[i])
        elif len(N[i-1])==len(N[i]):
            if int(N[i-1])>=int(N[i]):
                S+=1; MIN+=1
        else: 
            cond4=int(N[i-1][LEN:])!=int('9'*(len(N[i-1])-LEN))
            if cond1 or (cond2 and cond4):
                 S+=MIN-len(N[i])
            else:
                 S+=MIN-len(N[i])+1; MIN+=1
        i+=1
    print('Case #{}: {}'.format(t+1,S))

T=int(input())
for t in range(T):
    I=int(input())
    N=input()
    N=[n for n in N.split()]
    S,i=0,1
    print('before: ',t,N)
    while i<I:
        L1,L0=len(N[i]),len(N[i-1])
        DifL=L0-L1
        if DifL==0 and int(N[i])<=int(N[i-1]):
            S+=1; N[i]=N[i]+'0'
        elif DifL>0:
            if int(N[i]+DifL*'0')>int(N[i-1]):
                S+=DifL; N[i]=N[i]+DifL*'0'
            elif int(N[i]+DifL*'9')<=int(N[i-1]):
                S+=DifL+1; N[i]=N[i]+(DifL+1)*'0'
            elif int(N[i]+DifL*'0')<=int(N[i-1]) and \
            int(N[i]+DifL*'9')>int(N[i-1]):
                S+=DifL; N[i]=str(int(N[i-1])+1)
        i+=1
    print('after: ',t,N)
    print('Case #{}: {}'.format(t+1,S))

4
3
100 7 10
2
10 10
3
4 19 1
3
1 2 3

Case #1: 4
Case #2: 1
Case #3: 2
Case #4: 0

'100'<'7','700'<'7','7'<'30','70'=='70','a'<'b','ab'<'abc'

"""# Task 2. Prime Time (7pts, 13pts, 15pts)

Problem

You are playing a new solitaire game called Prime Time. 

You are given a deck of cards, and each card has a prime number written on it. 

Multiple cards may have the same number.

Your goal is to divide the cards into two groups in such a way that the sum of the numbers 

in the first group is equal to the product of the numbers in the second group.

Each card must belong to exactly one of the two groups, and each group must contain at least one card. 

The sum or product of a group that consists of a single card is simply the number on that card.

Sample Case #1

For example, in the image above, 

the left group has cards whose sum is 25 and the right group has cards whose product is 25. 

Therefore, this is a valid split into groups.

Your score is the sum of the numbers in the first group 

(which is equal to the product of the numbers in the second group), 

or 0 if you cannot split the cards this way at all. 

What is the maximum score you can achieve?

### Input
The first line of the input gives the number of test cases, T. 

T test cases follow. 

The first line of each test case contains a single integer M, representing the number of distinct prime numbers in your deck. 

Each of the next M lines contains two values: 

Pi and Ni, representing that you have exactly Ni cards with the prime Pi written on them.

Note that the total number of cards in your deck is the sum of all Nis.

### Output
For each test case, output one line containing Case #x: y, 

where x is the test case number (starting from 1) and y is the maximum score you can achieve.

### Limits

Time limit: 45 seconds.

Memory limit: 1 GB.

1≤T≤100.

1≤M≤95. (Note that there are exactly 95 distinct primes between 2 and 499)

2≤Pi≤499, for all i.

Each Pi is prime.

Pi<Pi+1, for all i. (The primes are given in strictly increasing order)

1≤Ni, for all i.

Test Set 1 (Visible Verdict)

2≤N1+N2+⋯+NM≤10.

Test Set 2 (Visible Verdict)

2≤N1+N2+⋯+NM≤100.

Test Set 3 (Hidden Verdict)

2≤N1+N2+⋯+NM≤10^15.

Sample

4

5

2 2

3 1

5 2

7 1

11 1

1

17 2

2

2 2

3 1

1

2 7

Sample Output

Case #1: 25

Case #2: 17

Case #3: 0

Case #4: 8

In Sample Case #1, the optimal split is: 11+2+7+3+2=5⋅5. 

Another split is also possible: 5+7+3+2+5=11⋅2, but it gives a lower score.

In Sample Case #2, note that cards with the same number can be placed in different groups.

# Task 3. Hacked Exam (8pts, 6pts, 25pts)

Problem

There is an exam with Q true or false questions. 

The correct answer to each question is either T or F. 

Each student taking the exam selects either T or F for each question, 

and the student's score is the number of questions they answer correctly.

Example Exam

There are N students who have already taken this exam. 

For each of those students, you know the answers they gave to each question and their final score. 

Assuming that any sequence of answers that is consistent with all of those students' scores 

has the same probability of being the correct sequence of answers, you want to maximize your own expected score. 

Determine what that expected score is and how to answer the questions so that you achieve it.

### Input
The first line of the input gives the number of test cases, T. 

T test cases follow. 

The first line of each test case contains two integers N and Q:

the number of students and the number of questions, respectively. 

Each of the next N lines contains a string Ai and an integer Si: 

the i-th student's answers and their score, respectively. 

The j-th character of Ai is either T or F, 

representing the answer the i-th student gave to the j-th question.

### Output
For each test case, output one line containing Case #x: y z/w, 

where x is the test case number (starting from 1), 

y is a string representing a sequence of answers that yields the maximum expected score 

(in the same format as the input), 

and z/w is the maximum expected score as an irreducible fraction 

(that is, w must be positive and of minimum possible value).

### Limits

Time limit: 30 seconds.

Memory limit: 1 GB.

1≤T≤2021.

The length of Ai=Q, for all i.

Each character of Ai is an uppercase T or an uppercase F, for all i.

0≤Si≤Q, for all i.

There exists at least one sequence of correct answers consistent with the input.

Test Set 1 (Visible Verdict)

1≤N≤2.

1≤Q≤10.

Test Set 2 (Hidden Verdict)

1≤N≤2.

1≤Q≤40.

Test Set 3 (Hidden Verdict)

1≤N≤3.

1≤Q≤120.

Sample

Note: there are additional samples that are not run on submissions down below.

Sample Input

4

1 3

FFT 3

1 3

FFT 2

2 6

FFTTTF 2

FTFTFT 4

2 2

FF 1

TT 1

Sample Output

Case #1: FFT 3/1

Case #2: FFT 2/1

Case #3: FTFFFT 4/1

Case #4: TF 1/1

In Sample Case #1, given that the score for FFT is 3, 

the sequence of correct answers must be FFT.

In Sample Case #2, given that the score for FFT is 2, 

the sequence of correct answers is FFF, FTT, or TFT, each with probability 1/3. 

Your best strategy is to answer FFT, to achieve the expected score of 1/3×2+1/3×2+1/3×2=2.

In Sample Case #3, there are other answers that also achieve an expected score of 4, like FTFTFT.

In Sample Case #4, one of the questions' answer is T and the other one is F,

but you do not know which is which. 

Answering TF or FT scores you 2 with probability 1/2 and 0 with probability 1/2, yielding an expected score of 1. 

Answering FF or TT guarantees a score of 1. 

Since any sequence of answers gives the same expected score, you can output any of them.

Additional Sample - Test Set 3

The following additional sample fits the limits of Test Set 3. 

It will not be run against your submitted solutions.

Sample Input

1

3 120

FFTFFFTFFFTTTTTTTFTFFFFFFTTTFTFFFTFTFFTTFTFFTFFTTTFTFTFFTFTFTTFFFFTFTFFFFTTTFTTFTTTTFFFTTFFFFFTTFFTFFTFFTTTFFFFTTFFTFTTF 55

FFFTFFTTFFFFTFTFFTFFFTTTTTTFFFTTTFTTTTFFTFTTTFTTFFTTTFTFFFFTFFTTFFTTFTTFFTFTFFTFTTFTFTFFTTTFFTFTFTTFFTFTFTFTTFFTFFFTFTFT 62

FFFTFTTFFFFFTFTFTTTTTTFFTTFTFFFTFFTTTTTTFFFTTTFFFTTFTFFFFFFTFTTFFTFTTTFTTTTFTTFFFFTFFTTFTFFTTTTTTFTFFFFFTTFFTFTFTFFTTTTT 64

Sample Output

Case #1: 

FFFTFTTTFFFFTFTFFTFTTTTTTTFFFFTTTFTTTTFFTFTTTTTFFFTFTFTFFFFTFFTTFTFTFTTTTTFFTFFFFFFFFTTFTTTTTTFTTTTFFFFTFTFTTFTFFFFTTTFT 

189154508532118369075350624633/2901503505434414233388602018

In the Sample Case for Test Set 3, you can get an expected score over 65, 

which is higher than the actual score of any of the other students. 

Notice that both the numerator and denominator of the expected score can be significantly larger than 2^64 

(the numerator in this case actually exceeds 2^97).
"""