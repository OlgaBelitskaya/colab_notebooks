# -*- coding: utf-8 -*-
"""coordinates.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17QfzKyhTZLJnfa0XKyf7c3Elgk6mWFf_
"""

!pip install git+https://github.com/tensorflow/docs

# Commented out IPython magic to ensure Python compatibility.
from IPython.display import display,HTML
c1,c2,f1,f2,fs1,fs2=\
'#ff1177','#7711ff','Wallpoet','Orbitron',20,10
def dhtml(string,fontcolor=c1,font=f1,fontsize=fs1):
    display(HTML("""<style>
    @import 'https://fonts.googleapis.com/css?family="""\
    +font+"""&effect=3d-float';</style>
    <h1 class='font-effect-3d-float' 
    style='font-family:"""+font+\
    """; color:"""+fontcolor+\
    """; font-size:"""+str(fontsize)+"""px;'>
#     %s</h1>"""%string))

dhtml('Code Modules, Setting, & Functions')

import warnings,urllib,imageio
import pylab as pl,tensorflow as tf
import pandas as pd,numpy as np
from mpl_toolkits.mplot3d import Axes3D
from tensorflow_docs.vis import embed
from tensorflow.keras.preprocessing import image as tkimg
from PIL import Image,ImageFile
ImageFile.LOAD_TRUNCATED_IMAGES=True

dhtml('Data')

path='https://olgabelitskaya.github.io/'
for zf in ['beethoven.csv',
           'castle.csv','horse.csv',
           'SpaceShuttle.csv',
           'SpaceShuttle2.csv',
           'TruncatedOctahedron.csv',
           'TruncatedOctahedron2.csv',
           'TruncatedIcosahedron.csv',
           'TruncatedIcosahedron2.csv']:
    input_file=urllib.request.urlopen(path+zf)
    output_file=open(zf,'wb'); 
    output_file.write(input_file.read())
    output_file.close(); input_file.close()

dhtml('Interpolation')

fp1='beethoven.csv'
fp2='castle.csv'
b=pd.read_csv(fp1)
c=pd.read_csv(fp2)
display(b.head(3).style\
.background_gradient(cmap='Spectral',axis=0))
(c.head(3)/50).style\
.background_gradient(cmap='Spectral',axis=0)

n=min(b.shape[0],c.shape[0]); n
b,c=b.loc[:n-1].values,c.loc[:n-1].values
b.shape[0],c.shape[0]

def interpolate_hypersphere(v1,v2,steps):
    v1norm=tf.norm(v1)
    v2norm=tf.norm(v2)
    v2normalized=v2*(v1norm/v2norm)
    vectors=[]
    for step in range(steps):
        interpolated=v1+(v2normalized-v1)*step/(steps-1)
        interpolated_norm=tf.norm(interpolated)
        interpolated_normalized=\
        interpolated*(v1norm/interpolated_norm)
        vectors.append(interpolated_normalized)
    return tf.stack(vectors).numpy()

steps=12
a=interpolate_hypersphere(b,c,steps)
a.shape

dhtml('Plotting')

f=pl.figure(figsize=(10,12))
for i in range(steps):
    ax=f.add_subplot(4,steps//4,i+1,projection='3d')
    ax.scatter3D(a[i][:,0],a[i][:,1],a[i][:,2],
                 color=np.random.random(3),s=.1)
    ax.set_axis_off();

dhtml('Trajectory Checking')

f=pl.figure(figsize=(10,10))
ax=f.add_subplot(111,projection='3d')
for i in range(100,200,10):
    x=np.squeeze(a[:,i:i+1,0])
    y=np.squeeze(a[:,i:i+1,1])
    z=np.squeeze(a[:,i:i+1,2])
    ax.plot(x,y,z,color=np.random.random(3));

dhtml('3D Sculptures')

fp3='horse.csv'
h=pd.read_csv(fp3)
hv=h.values*10
display(h.head(3).style\
.background_gradient(cmap='Spectral',axis=0))

f=pl.figure(figsize=(5,5))
ax=f.add_subplot(111,projection='3d')
ax.scatter3D(hv[:,0],hv[:,1],hv[:,2],
             color=np.random.random(3),s=.1)
ax.set_xlim([-1,1]); ax.set_ylim([-1,1])
ax.set_zlim([-1,1]); ax.set_axis_off()

dhtml('Polyhedrons')
#{Cuboctahedron,GreatRhombicosidodecahedron,GreatRhombicuboctahedron,Icosidodecahedron,
#SmallRhombicosidodecahedron,SmallRhombicuboctahedron,SnubCube,SnubDodecahedron,TruncatedCube,
#TruncatedDodecahedron,TruncatedIcosahedron,TruncatedOctahedron,TruncatedTetrahedron}

dfv=pd.read_csv('TruncatedIcosahedron.csv')
dfe=pd.read_csv('TruncatedIcosahedron2.csv')
display(dfv.head(3).style\
.background_gradient(cmap='Spectral',axis=0))
display(dfe.head(3).style\
.background_gradient(cmap='Spectral',axis=0))
f=pl.figure(figsize=(5,5))
ax=f.add_subplot(111,projection='3d')
v=dfv.values; e=dfe.values
for i in range(e.shape[0]):
    ax.plot(v[e[i]-1,0],v[e[i]-1,1],v[e[i]-1,2],
            color=c1);
    ax.plot(2*v[e[i]-1,0],2*v[e[i]-1,1],2*v[e[i]-1,2],
            color=c2)
ax.set_axis_off(); pl.show()

dhtml('Animation')

dfv2=pd.read_csv(path+'SpaceShuttle.csv')
dfe2=pd.read_csv(path+'SpaceShuttle2.csv')
dfe2['v5']=0
display(dfv2.tail(3).style\
.background_gradient(cmap='Spectral',axis=0))
display(dfe2.tail(3).style\
.background_gradient(cmap='Spectral',axis=0))
v2=dfv2.values; e2=dfe2.values
e2[:,4][e2[:,3]!=0]=e2[:,0][e2[:,3]!=0]
e2[:,3][e2[:,3]==0]=e2[:,0][e2[:,3]==0]
for j in range(2):
    f=pl.figure(figsize=(10,10))
    ax=f.add_subplot(111,projection='3d')
    for i in range(e2.shape[0]):
        ed=[el-1 for el in e2[i] if el!=0]
        ax.plot((j+1)*v2[ed,0],
                (j+1)*v2[ed,1],
                (j+1)*v2[ed,2],
                color=c1,lw=1)
    ax.set_xlim([-10,10]); ax.set_ylim([-5,5])
    ax.set_zlim([-10,10]); ax.set_axis_off()
    pl.savefig('vf%s'%(j+1)); pl.close()

def show_interpolate(f1,f2,steps):
    img1=tf.image.decode_image(tf.io.read_file(f1))
    img1=img1.numpy()[:,:,:3]/255.
    pl.subplot(1,2,1); pl.imshow(img1)
    img2=tf.image.decode_image(tf.io.read_file(f2))
    img2=img2.numpy()[:,:,:3]/255.
    pl.subplot(1,2,2); pl.imshow(img2)
    pl.show()
    if1=interpolate_hypersphere(img1,img2,steps)
    if2=interpolate_hypersphere(img2,img1,steps)
    return np.vstack([if1,if2])
images=show_interpolate('vf1.png','vf2.png',30)
images.shape

def animate(images):
    converted_images=np.clip(images*255,0,255)\
    .astype(np.uint8)
    imageio.mimsave('animation.gif',converted_images)
    return embed.embed_file('animation.gif')
animate(images)